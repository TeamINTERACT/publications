"""
Author: Kole Phillips

Using the CSV files generated by slope_breakpoint_metric_calcs.py that have been combined with the NHANES 2013-2014 questionnaire, an
ANalysis Of VAriance test is performed, comparing each column of our metrics to the NHANES survey columns. Uses R
functionality rather than scipy so that we can access the coefficients of each variable as well.

Usage: python anova.py
"""

import pandas as pd
import numpy as np
from rpy2 import robjects
from rpy2.robjects.packages import importr
rstat = importr('stats')
base = importr('base')


if __name__ == '__main__':
    # Removal of columns that were created by pandas when merging the survey and metric dataframes
    df = pd.read_csv('nhanes_classified_demographics_0.csv').dropna(axis=1, how='all').drop(labels=['Unnamed: 0', 'Unnamed: 0_x', 'Unnamed: 0.1'], axis=1)
    df['max_val'] = df['tail']
    df = df.drop(labels='tail', axis=1)
    age_cols = ['RIDAGEYR', 'DMDHRAGE']

    # Renaming columns that are incompatible with R, then putting each column into a vector for R
    for col in df.columns:
        if col == 'iid':
            continue
        col_x = col.replace('4-', 'Four_').replace('3-', 'Three_').replace('class', 'categ')
        if str(df[col].dtype) == 'object':
            # Key to convert 'class' column into integers
            conversion = {'A': 3, 'B': 2, 'C': 1, 'D': 4, 'E': 5}
            fixcol = df[col]
            for c in conversion:
                fixcol[fixcol == c] = conversion[c]
            robjects.globalenv[col_x] = robjects.FloatVector(fixcol.tolist())
        else:
            if col_x in age_cols:
                robjects.globalenv[col_x] = robjects.StrVector(np.floor(df[col] / 10).astype(str).tolist())
            elif col_x.isupper():
                robjects.globalenv[col_x] = robjects.StrVector(df[col].round().astype(str).tolist())
            else:
                robjects.globalenv[col_x] = robjects.FloatVector(df[col].tolist())

    results = pd.DataFrame()
    # Run the ANOVA test on each pair of columns in the dataset
    for i in df.columns:
        for j in df.columns:
            if i == j or i == 'iid' or j == 'iid' or j in ['WTINT2YR', 'WTMEC2YR', 'SDMVSTRA', 'RIDEXAGM', 'DMDBORN4']:
                # Skipping certain columns
                continue
            if 'tail_' in i or '_auc_' in i or 'r_square' in i:
                continue
            if np.all(np.logical_or(df[i].isna(), df[j].isna())):
                # Ignore blank columns
                continue
            if i.isupper() or not j.isupper():
                # The naming conventions for NHANES surveys are all uppercase while our metric CSVs are all lowercase,
                # meaning we can use the columns' cases to avoid comparing survey columns to survey columns or metric
                # columns to metric columns. Will likely need to be changed or removed with other datasets
                continue
            if len(df[j].unique()) < 2:
                # Make sure there is more than one answer among participants in the survey column
                continue
            i_x = i.replace('4-', 'Four_').replace('3-', 'Three_').replace('class', 'categ')
            j_x = j.replace('4-', 'Four_').replace('3-', 'Three_').replace('class', 'categ')
            new_row = pd.Series()
            new_row['i'] = i
            new_row['j'] = j
            lm = rstat.lm(i_x + ' ~ ' + j_x)

            coefs = lm.rx2('coefficients')
            coef_pvals = base.summary(lm)[3].rx(True, 4)
            values = [x.replace(j, '').replace('(', '').replace(')', '').replace('.0', '') for x in coefs.names]

            # Save coefficients and their p-values
            new_row['coeff_intercept'] = coefs[0]
            new_row['coeff_intercept_pval'] = coef_pvals[0]
            for c in range(1, len(values)):
                new_row['coeff_' + str(values[c])] = coefs[c]
                new_row['coeff_' + str(values[c]) + '_pval'] = coef_pvals[c]

            # Save overall F-score
            anova = rstat.anova(lm)
            new_row['prF'] = rstat.anova(lm)[4][0]
            results = results.append(new_row, ignore_index=True)
    results.to_csv('anova_results.csv', index=False)
